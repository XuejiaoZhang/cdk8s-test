"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const MAX_DNS_NAME_LEN = 63;
const VALIDATE = /^[0-9a-z-]+$/;
const HASH_LEN = 8;
/**
 * Utilities for generating unique and stable names.
 */
class Names {
    /**
     * Generates a unique and stable name compatible DNS_LABEL from RFC-1123 from
     * a path.
     *
     * The generated name will:
     *  - contain at most 63 characters
     *  - contain only lowercase alphanumeric characters or ‘-’
     *  - start with an alphanumeric character
     *  - end with an alphanumeric character
     *
     * The generated name will have the form:
     *  <comp0>-<comp1>-..-<compN>-<short-hash>
     *
     * Where <comp> are the path components (assuming they are is separated by
     * "/").
     *
     * Note that if the total length is longer than 63 characters, we will trim
     * the first components since the last components usually encode more meaning.
     *
     * @link https://tools.ietf.org/html/rfc1123
     *
     * @param path a path to a node (components separated by "/")
     * @param maxLen maximum allowed length for name
     * @throws if any of the components do not adhere to naming constraints or
     * length.
     */
    static toDnsLabel(path, maxLen = MAX_DNS_NAME_LEN) {
        if (maxLen < HASH_LEN) {
            throw new Error(`minimum max length for object names is ${HASH_LEN} (required for hash)`);
        }
        const components = path.split('/');
        // verify components only use allowed chars.
        for (const comp of components) {
            if (!VALIDATE.test(comp)) {
                throw new Error(`"${comp}" is not a valid object name. The characters allowed in names are: digits (0-9), lower case letters (a-z), -, and .`);
            }
            if (comp.length > maxLen) {
                throw new Error(`Object name "${comp}" is too long. Maximum allowed length is ${maxLen}`);
            }
        }
        // special case: if we only have one component in our path, we don't decorate it
        if (components.length === 1) {
            return components[0];
        }
        components.push(calcHash(path, HASH_LEN));
        return components
            .reverse()
            .join('/')
            .slice(0, maxLen)
            .split('/')
            .reverse()
            .filter(x => x)
            .join('-');
    }
    /* istanbul ignore next */
    constructor() {
        return;
    }
}
exports.Names = Names;
function calcHash(path, maxLen) {
    const hash = crypto.createHash('sha256');
    hash.update(path);
    return hash.digest('hex').slice(0, maxLen);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFtZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJuYW1lcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFpQztBQUVqQyxNQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUM1QixNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUM7QUFDaEMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBRW5COztHQUVHO0FBQ0gsTUFBYSxLQUFLO0lBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUJHO0lBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFZLEVBQUUsTUFBTSxHQUFHLGdCQUFnQjtRQUM5RCxJQUFJLE1BQU0sR0FBRyxRQUFRLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsUUFBUSxzQkFBc0IsQ0FBQyxDQUFDO1NBQzNGO1FBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVuQyw0Q0FBNEM7UUFDNUMsS0FBSyxNQUFNLElBQUksSUFBSSxVQUFVLEVBQUU7WUFDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLHFIQUFxSCxDQUFDLENBQUM7YUFDaEo7WUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFO2dCQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixJQUFJLDRDQUE0QyxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQzNGO1NBQ0Y7UUFFRCxnRkFBZ0Y7UUFDaEYsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzQixPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtRQUVELFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBRTFDLE9BQU8sVUFBVTthQUNkLE9BQU8sRUFBRTthQUNULElBQUksQ0FBQyxHQUFHLENBQUM7YUFDVCxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQzthQUNoQixLQUFLLENBQUMsR0FBRyxDQUFDO2FBQ1YsT0FBTyxFQUFFO2FBQ1QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztJQUVELDBCQUEwQjtJQUMxQjtRQUNFLE9BQU87SUFDVCxDQUFDO0NBQ0Y7QUFsRUQsc0JBa0VDO0FBRUQsU0FBUyxRQUFRLENBQUMsSUFBWSxFQUFFLE1BQWM7SUFDNUMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN6QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzdDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuY29uc3QgTUFYX0ROU19OQU1FX0xFTiA9IDYzO1xuY29uc3QgVkFMSURBVEUgPSAvXlswLTlhLXotXSskLztcbmNvbnN0IEhBU0hfTEVOID0gODtcblxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGFuZCBzdGFibGUgbmFtZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lcyB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgYW5kIHN0YWJsZSBuYW1lIGNvbXBhdGlibGUgRE5TX0xBQkVMIGZyb20gUkZDLTExMjMgZnJvbVxuICAgKiBhIHBhdGguXG4gICAqXG4gICAqIFRoZSBnZW5lcmF0ZWQgbmFtZSB3aWxsOlxuICAgKiAgLSBjb250YWluIGF0IG1vc3QgNjMgY2hhcmFjdGVyc1xuICAgKiAgLSBjb250YWluIG9ubHkgbG93ZXJjYXNlIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yIOKAmC3igJlcbiAgICogIC0gc3RhcnQgd2l0aCBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyXG4gICAqICAtIGVuZCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJcbiAgICpcbiAgICogVGhlIGdlbmVyYXRlZCBuYW1lIHdpbGwgaGF2ZSB0aGUgZm9ybTpcbiAgICogIDxjb21wMD4tPGNvbXAxPi0uLi08Y29tcE4+LTxzaG9ydC1oYXNoPlxuICAgKlxuICAgKiBXaGVyZSA8Y29tcD4gYXJlIHRoZSBwYXRoIGNvbXBvbmVudHMgKGFzc3VtaW5nIHRoZXkgYXJlIGlzIHNlcGFyYXRlZCBieVxuICAgKiBcIi9cIikuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB0aGUgdG90YWwgbGVuZ3RoIGlzIGxvbmdlciB0aGFuIDYzIGNoYXJhY3RlcnMsIHdlIHdpbGwgdHJpbVxuICAgKiB0aGUgZmlyc3QgY29tcG9uZW50cyBzaW5jZSB0aGUgbGFzdCBjb21wb25lbnRzIHVzdWFsbHkgZW5jb2RlIG1vcmUgbWVhbmluZy5cbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjNcbiAgICpcbiAgICogQHBhcmFtIHBhdGggYSBwYXRoIHRvIGEgbm9kZSAoY29tcG9uZW50cyBzZXBhcmF0ZWQgYnkgXCIvXCIpXG4gICAqIEBwYXJhbSBtYXhMZW4gbWF4aW11bSBhbGxvd2VkIGxlbmd0aCBmb3IgbmFtZVxuICAgKiBAdGhyb3dzIGlmIGFueSBvZiB0aGUgY29tcG9uZW50cyBkbyBub3QgYWRoZXJlIHRvIG5hbWluZyBjb25zdHJhaW50cyBvclxuICAgKiBsZW5ndGguXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRvRG5zTGFiZWwocGF0aDogc3RyaW5nLCBtYXhMZW4gPSBNQVhfRE5TX05BTUVfTEVOKSB7XG4gICAgaWYgKG1heExlbiA8IEhBU0hfTEVOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pbmltdW0gbWF4IGxlbmd0aCBmb3Igb2JqZWN0IG5hbWVzIGlzICR7SEFTSF9MRU59IChyZXF1aXJlZCBmb3IgaGFzaClgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgLy8gdmVyaWZ5IGNvbXBvbmVudHMgb25seSB1c2UgYWxsb3dlZCBjaGFycy5cbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcG9uZW50cykge1xuICAgICAgaWYgKCFWQUxJREFURS50ZXN0KGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2NvbXB9XCIgaXMgbm90IGEgdmFsaWQgb2JqZWN0IG5hbWUuIFRoZSBjaGFyYWN0ZXJzIGFsbG93ZWQgaW4gbmFtZXMgYXJlOiBkaWdpdHMgKDAtOSksIGxvd2VyIGNhc2UgbGV0dGVycyAoYS16KSwgLSwgYW5kIC5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXAubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IG5hbWUgXCIke2NvbXB9XCIgaXMgdG9vIGxvbmcuIE1heGltdW0gYWxsb3dlZCBsZW5ndGggaXMgJHttYXhMZW59YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB3ZSBvbmx5IGhhdmUgb25lIGNvbXBvbmVudCBpbiBvdXIgcGF0aCwgd2UgZG9uJ3QgZGVjb3JhdGUgaXRcbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRzWzBdO1xuICAgIH1cblxuICAgIGNvbXBvbmVudHMucHVzaChjYWxjSGFzaChwYXRoLCBIQVNIX0xFTikpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5qb2luKCcvJylcbiAgICAgIC5zbGljZSgwLCBtYXhMZW4pXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbHRlcih4ID0+IHgpXG4gICAgICAuam9pbignLScpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY0hhc2gocGF0aDogc3RyaW5nLCBtYXhMZW46IG51bWJlcikge1xuICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICBoYXNoLnVwZGF0ZShwYXRoKTtcbiAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKS5zbGljZSgwLCBtYXhMZW4pO1xufSJdfQ==