"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logging_1 = require("./logging");
const os_1 = require("./os");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 *
 * When running in CI, we pull the latest image first and use it as cache for
 * the build. Generally pulling will be faster than building, especially for
 * Dockerfiles with lots of OS/code packages installation or changes only in
 * the bottom layers. When running locally chances are that we already have
 * layers cache available.
 *
 * CI is detected by the presence of the `CI` environment variable or
 * the `--ci` command line option.
 */
async function prepareContainerAsset(assemblyDir, asset, toolkitInfo, reuse, ci) {
    var _a, _b;
    // following 1.21.0, image asset location (repositoryName and imageTag) is fully determined by the
    // app, and therefore there is no need to wire the image name through a cloudformation parameter.
    if (!asset.imageNameParameter) {
        await prepareContainerAssetNew(assemblyDir, asset, toolkitInfo);
        return [];
    }
    if (reuse) {
        return [
            { ParameterKey: asset.imageNameParameter, UsePreviousValue: true },
        ];
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    try {
        const repositoryName = (_a = asset.repositoryName) !== null && _a !== void 0 ? _a : 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
        const ecr = await toolkitInfo.prepareEcrRepository(repositoryName);
        const imageTag = (_b = asset.imageTag) !== null && _b !== void 0 ? _b : 'latest';
        const latest = `${ecr.repositoryUri}:${imageTag}`;
        let loggedIn = false;
        // In CI we try to pull latest first
        if (ci) {
            await dockerLogin(toolkitInfo);
            loggedIn = true;
            try {
                await os_1.shell(['docker', 'pull', latest]);
            }
            catch (e) {
                logging_1.debug('Failed to pull latest image from ECR repository');
            }
        }
        const buildArgs = [].concat(...Object.entries(asset.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`]));
        const baseCommand = [
            'docker', 'build',
            ...buildArgs,
            '--tag', latest,
            contextPath
        ];
        if (asset.target) {
            baseCommand.push('--target', asset.target);
        }
        if (asset.file) {
            // remember we assume the file is relative (we validate this in the asset constructor)
            baseCommand.push('--file', path.join(contextPath, asset.file));
        }
        const command = ci
            ? [...baseCommand, '--cache-from', latest] // This does not fail if latest is not available
            : baseCommand;
        await os_1.shell(command);
        // Login and push
        if (!loggedIn) { // We could be already logged in if in CI
            await dockerLogin(toolkitInfo);
            loggedIn = true;
        }
        // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
        logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
        await os_1.shell(['docker', 'push', latest]);
        logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
        // Get the (single) repo-digest for latest, which'll be <ecr.repositoryUrl>@sha256:<repoImageSha256>
        const repoDigests = (await os_1.shell(['docker', 'image', 'inspect', latest, '--format', '{{range .RepoDigests}}{{.}}|{{end}}'])).trim();
        const requiredPrefix = `${ecr.repositoryUri}@sha256:`;
        const repoDigest = repoDigests.split('|').find(digest => digest.startsWith(requiredPrefix));
        if (!repoDigest) {
            throw new Error(`Unable to identify repository digest (none starts with ${requiredPrefix}) in:\n${repoDigests}`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: repoDigest.replace(ecr.repositoryUri, repositoryName) },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Build and upload a Docker image
 */
async function prepareContainerAssetNew(assemblyDir, asset, toolkitInfo) {
    if (asset.imageNameParameter || !asset.repositoryName || !asset.imageTag) {
        throw new Error(`invalid docker image asset configuration. "repositoryName" and "imageTag" are required and "imageNameParameter" is not allowed`);
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    const ecr = await toolkitInfo.prepareEcrRepository(asset.repositoryName);
    // if both repo name and image tag are explicitly defined, we assume the
    // image is immutable and can skip build & push.
    logging_1.debug(`${asset.repositoryName}:${asset.imageTag}: checking if image already exists`);
    if (await toolkitInfo.checkEcrImage(asset.repositoryName, asset.imageTag)) {
        logging_1.print(`${asset.repositoryName}:${asset.imageTag}: image already exists, skipping build and push`);
        return;
    }
    // we use "latest" for image tag for backwards compatibility with pre-1.21.0 apps.
    const fullImageName = `${ecr.repositoryUri}:${asset.imageTag}`;
    // render "docker build" command
    const buildCommand = ['docker', 'build'];
    buildCommand.push('--tag', fullImageName);
    if (asset.target) {
        buildCommand.push('--target', asset.target);
    }
    if (asset.file) {
        // remember we assume the file is relative (we validate this in the asset constructor)
        buildCommand.push('--file', path.join(contextPath, asset.file));
    }
    for (const [key, value] of Object.entries(asset.buildArgs || {})) {
        buildCommand.push(`--build-arg`, `${key}=${value}`);
    }
    buildCommand.push(contextPath);
    // Login to ECR before build to allow building images that reference other docker assets
    try {
        await dockerLogin(toolkitInfo);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            throw new Error('Unable to execute "docker" in order to build a container asset. Please install "docker" and try again.');
        }
        throw e;
    }
    await os_1.shell(buildCommand);
    // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
    logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
    await os_1.shell(['docker', 'push', fullImageName]);
    logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
}
exports.prepareContainerAssetNew = prepareContainerAssetNew;
/**
 * Get credentials from ECR and run docker login
 */
async function dockerLogin(toolkitInfo) {
    const credentials = await toolkitInfo.getEcrCredentials();
    await os_1.shell(['docker', 'login',
        '--username', credentials.username,
        '--password', credentials.password,
        credentials.endpoint]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsNkJBQTZCO0FBRTdCLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxXQUFtQixFQUNuQixLQUF1QyxFQUN2QyxXQUF3QixFQUN4QixLQUFjLEVBQ2QsRUFBWTs7SUFFdEQsa0dBQWtHO0lBQ2xHLGlHQUFpRztJQUNqRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFO1FBQzdCLE1BQU0sd0JBQXdCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztRQUNoRSxPQUFPLEVBQUcsQ0FBQztLQUNaO0lBRUQsSUFBSSxLQUFLLEVBQUU7UUFDVCxPQUFPO1lBQ0wsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRTtTQUNuRSxDQUFDO0tBQ0g7SUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxHLGVBQUssQ0FBQyxvQ0FBb0MsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUV6RCxJQUFJO1FBQ0YsTUFBTSxjQUFjLFNBQUcsS0FBSyxDQUFDLGNBQWMsbUNBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyRyxNQUFNLEdBQUcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FB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QUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0dBQXdHLENBQUMsQ0FBQztTQUMzSDtRQUNELE1BQU0sQ0FBQyxDQUFDO0tBQ1Q7SUFFRCxNQUFNLFVBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUUxQiwyRkFBMkY7SUFDM0YsZUFBSyxDQUFDLCtCQUErQixXQUFXLDBCQUEwQixDQUFDLENBQUM7SUFDNUUsTUFBTSxVQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDL0MsZUFBSyxDQUFDLHlCQUF5QixXQUFXLFVBQVUsQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUE3REQsNERBNkRDO0FBRUQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsV0FBVyxDQUFDLFdBQXdCO0lBQ2pELE1BQU0sV0FBVyxHQUFHLE1BQU0sV0FBVyxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDMUQsTUFBTSxVQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTztRQUM5QixZQUFZLEVBQUUsV0FBVyxDQUFDLFFBQVE7UUFDbEMsWUFBWSxFQUFFLFdBQVcsQ0FBQyxRQUFRO1FBQ2xDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi9hcGkvdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IGRlYnVnLCBwcmludCB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4vb3MnO1xuXG4vKipcbiAqIEJ1aWxkIGFuZCB1cGxvYWQgYSBEb2NrZXIgaW1hZ2VcbiAqXG4gKiBQZXJtYW5lbnRseSBpZGVudGlmeWluZyBpbWFnZXMgaXMgYSBiaXQgb2YgYSBidXN0LiBOZXdlciBEb2NrZXIgdmVyc2lvbiB1c2VcbiAqIGEgZGlnZXN0IChzaGEyNTY6eHh4eCkgYXMgYW4gaW1hZ2UgaWRlbnRpZmllciwgd2hpY2ggaXMgcHJldHR5IGdvb2QgdG8gYXZvaWRcbiAqIHNwdXJpb3VzIHJlYnVpbGRzLiBIb3dldmVyLCB0aGlzIGRpZ2VzdCBpcyBjYWxjdWxhdGVkIG92ZXIgYSBtYW5pZmVzdCB0aGF0XG4gKiBpbmNsdWRlcyBtZXRhZGF0YSB0aGF0IGlzIGxpYWJsZSB0byBjaGFuZ2UuIEZvciBleGFtcGxlLCBhcyBzb29uIGFzIHdlXG4gKiBwdXNoIHRoZSBEb2NrZXIgaW1hZ2UgdG8gYSByZXBvc2l0b3J5LCB0aGUgZGlnZXN0IGNoYW5nZXMuIFRoaXMgbWFrZXMgdGhlXG4gKiBkaWdlc3Qgd29ydGhsZXNzIHRvIGRldGVybWUgd2hldGhlciB3ZSBhbHJlYWR5IHB1c2hlZCBhbiBpbWFnZSwgZm9yIGV4YW1wbGUuXG4gKlxuICogQXMgYSB3b3JrYXJvdW5kLCB3ZSBjYWxjdWxhdGUgb3VyIG93biBkaWdlc3Qgb3ZlciBwYXJ0cyBvZiB0aGUgbWFuaWZlc3QgdGhhdFxuICogYXJlIHVubGlrZWx5IHRvIGNoYW5nZSwgYW5kIHRhZyBiYXNlZCBvbiB0aGF0LlxuICpcbiAqIFdoZW4gcnVubmluZyBpbiBDSSwgd2UgcHVsbCB0aGUgbGF0ZXN0IGltYWdlIGZpcnN0IGFuZCB1c2UgaXQgYXMgY2FjaGUgZm9yXG4gKiB0aGUgYnVpbGQuIEdlbmVyYWxseSBwdWxsaW5nIHdpbGwgYmUgZmFzdGVyIHRoYW4gYnVpbGRpbmcsIGVzcGVjaWFsbHkgZm9yXG4gKiBEb2NrZXJmaWxlcyB3aXRoIGxvdHMgb2YgT1MvY29kZSBwYWNrYWdlcyBpbnN0YWxsYXRpb24gb3IgY2hhbmdlcyBvbmx5IGluXG4gKiB0aGUgYm90dG9tIGxheWVycy4gV2hlbiBydW5uaW5nIGxvY2FsbHkgY2hhbmNlcyBhcmUgdGhhdCB3ZSBhbHJlYWR5IGhhdmVcbiAqIGxheWVycyBjYWNoZSBhdmFpbGFibGUuXG4gKlxuICogQ0kgaXMgZGV0ZWN0ZWQgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBgQ0lgIGVudmlyb25tZW50IHZhcmlhYmxlIG9yXG4gKiB0aGUgYC0tY2lgIGNvbW1hbmQgbGluZSBvcHRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udGFpbmVyQXNzZXQoYXNzZW1ibHlEaXI6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXQ6IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldXNlOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaT86IGJvb2xlYW4pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLlBhcmFtZXRlcltdPiB7XG5cbiAgLy8gZm9sbG93aW5nIDEuMjEuMCwgaW1hZ2UgYXNzZXQgbG9jYXRpb24gKHJlcG9zaXRvcnlOYW1lIGFuZCBpbWFnZVRhZykgaXMgZnVsbHkgZGV0ZXJtaW5lZCBieSB0aGVcbiAgLy8gYXBwLCBhbmQgdGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2lyZSB0aGUgaW1hZ2UgbmFtZSB0aHJvdWdoIGEgY2xvdWRmb3JtYXRpb24gcGFyYW1ldGVyLlxuICBpZiAoIWFzc2V0LmltYWdlTmFtZVBhcmFtZXRlcikge1xuICAgIGF3YWl0IHByZXBhcmVDb250YWluZXJBc3NldE5ldyhhc3NlbWJseURpciwgYXNzZXQsIHRvb2xraXRJbmZvKTtcbiAgICByZXR1cm4gWyBdO1xuICB9XG5cbiAgaWYgKHJldXNlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgUGFyYW1ldGVyS2V5OiBhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIsIFVzZVByZXZpb3VzVmFsdWU6IHRydWUgfSxcbiAgICBdO1xuICB9XG5cbiAgY29uc3QgY29udGV4dFBhdGggPSBwYXRoLmlzQWJzb2x1dGUoYXNzZXQucGF0aCkgPyBhc3NldC5wYXRoIDogcGF0aC5qb2luKGFzc2VtYmx5RGlyLCBhc3NldC5wYXRoKTtcblxuICBkZWJ1ZygnIPCfkZEgIFByZXBhcmluZyBEb2NrZXIgaW1hZ2UgYXNzZXQ6JywgY29udGV4dFBhdGgpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVwb3NpdG9yeU5hbWUgPSBhc3NldC5yZXBvc2l0b3J5TmFtZSA/PyAnY2RrLycgKyBhc3NldC5pZC5yZXBsYWNlKC9bOi9dL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0b29sa2l0SW5mby5wcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZSk7XG4gICAgY29uc3QgaW1hZ2VUYWcgPSBhc3NldC5pbWFnZVRhZyA/PyAnbGF0ZXN0JztcbiAgICBjb25zdCBsYXRlc3QgPSBgJHtlY3IucmVwb3NpdG9yeVVyaX06JHtpbWFnZVRhZ31gO1xuXG4gICAgbGV0IGxvZ2dlZEluID0gZmFsc2U7XG5cbiAgICAvLyBJbiBDSSB3ZSB0cnkgdG8gcHVsbCBsYXRlc3QgZmlyc3RcbiAgICBpZiAoY2kpIHtcbiAgICAgIGF3YWl0IGRvY2tlckxvZ2luKHRvb2xraXRJbmZvKTtcbiAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc2hlbGwoWydkb2NrZXInLCAncHVsbCcsIGxhdGVzdF0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnRmFpbGVkIHRvIHB1bGwgbGF0ZXN0IGltYWdlIGZyb20gRUNSIHJlcG9zaXRvcnknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBidWlsZEFyZ3MgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdCguLi5PYmplY3QuZW50cmllcyhhc3NldC5idWlsZEFyZ3MgfHwge30pLm1hcCgoW2ssIHZdKSA9PiBbJy0tYnVpbGQtYXJnJywgYCR7a309JHt2fWBdKSk7XG5cbiAgICBjb25zdCBiYXNlQ29tbWFuZCA9IFtcbiAgICAgICdkb2NrZXInLCAnYnVpbGQnLFxuICAgICAgLi4uYnVpbGRBcmdzLFxuICAgICAgJy0tdGFnJywgbGF0ZXN0LFxuICAgICAgY29udGV4dFBhdGhcbiAgICBdO1xuXG4gICAgaWYgKGFzc2V0LnRhcmdldCkge1xuICAgICAgYmFzZUNvbW1hbmQucHVzaCgnLS10YXJnZXQnLCBhc3NldC50YXJnZXQpO1xuICAgIH1cblxuICAgIGlmIChhc3NldC5maWxlKSB7XG4gICAgICAvLyByZW1lbWJlciB3ZSBhc3N1bWUgdGhlIGZpbGUgaXMgcmVsYXRpdmUgKHdlIHZhbGlkYXRlIHRoaXMgaW4gdGhlIGFzc2V0IGNvbnN0cnVjdG9yKVxuICAgICAgYmFzZUNvbW1hbmQucHVzaCgnLS1maWxlJywgcGF0aC5qb2luKGNvbnRleHRQYXRoLCBhc3NldC5maWxlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tbWFuZCA9IGNpXG4gICAgICA/IFsuLi5iYXNlQ29tbWFuZCwgJy0tY2FjaGUtZnJvbScsIGxhdGVzdF0gLy8gVGhpcyBkb2VzIG5vdCBmYWlsIGlmIGxhdGVzdCBpcyBub3QgYXZhaWxhYmxlXG4gICAgICA6IGJhc2VDb21tYW5kO1xuICAgIGF3YWl0IHNoZWxsKGNvbW1hbmQpO1xuXG4gICAgLy8gTG9naW4gYW5kIHB1c2hcbiAgICBpZiAoIWxvZ2dlZEluKSB7IC8vIFdlIGNvdWxkIGJlIGFscmVhZHkgbG9nZ2VkIGluIGlmIGluIENJXG4gICAgICBhd2FpdCBkb2NrZXJMb2dpbih0b29sa2l0SW5mbyk7XG4gICAgICBsb2dnZWRJbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhlcmUncyBubyB3YXkgdG8gbWFrZSB0aGlzIHF1aWV0LCBzbyB3ZSBjYW4ndCB1c2UgYSBQbGVhc2VIb2xkLiBQcmludCBhIGhlYWRlciBtZXNzYWdlLlxuICAgIHByaW50KGAg4oybIFB1c2hpbmcgRG9ja2VyIGltYWdlIGZvciAke2NvbnRleHRQYXRofTsgdGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICAgIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ3B1c2gnLCBsYXRlc3RdKTtcbiAgICBkZWJ1ZyhgIPCfkZEgIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH0gcHVzaGVkLmApO1xuXG4gICAgLy8gR2V0IHRoZSAoc2luZ2xlKSByZXBvLWRpZ2VzdCBmb3IgbGF0ZXN0LCB3aGljaCdsbCBiZSA8ZWNyLnJlcG9zaXRvcnlVcmw+QHNoYTI1Njo8cmVwb0ltYWdlU2hhMjU2PlxuICAgIGNvbnN0IHJlcG9EaWdlc3RzID0gKGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2ltYWdlJywgJ2luc3BlY3QnLCBsYXRlc3QsICctLWZvcm1hdCcsICd7e3JhbmdlIC5SZXBvRGlnZXN0c319e3sufX18e3tlbmR9fSddKSkudHJpbSgpO1xuICAgIGNvbnN0IHJlcXVpcmVkUHJlZml4ID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9QHNoYTI1NjpgO1xuICAgIGNvbnN0IHJlcG9EaWdlc3QgPSByZXBvRGlnZXN0cy5zcGxpdCgnfCcpLmZpbmQoZGlnZXN0ID0+IGRpZ2VzdC5zdGFydHNXaXRoKHJlcXVpcmVkUHJlZml4KSk7XG4gICAgaWYgKCFyZXBvRGlnZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBpZGVudGlmeSByZXBvc2l0b3J5IGRpZ2VzdCAobm9uZSBzdGFydHMgd2l0aCAke3JlcXVpcmVkUHJlZml4fSkgaW46XFxuJHtyZXBvRGlnZXN0c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgeyBQYXJhbWV0ZXJLZXk6IGFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciwgUGFyYW1ldGVyVmFsdWU6IHJlcG9EaWdlc3QucmVwbGFjZShlY3IucmVwb3NpdG9yeVVyaSwgcmVwb3NpdG9yeU5hbWUpIH0sXG4gICAgXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJ1aWxkaW5nIERvY2tlciBpbWFnZSBhc3NldDsgeW91IG5lZWQgdG8gaGF2ZSBEb2NrZXIgaW5zdGFsbGVkIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gYnVpbGQgaW1hZ2UgYXNzZXRzLiBQbGVhc2UgaW5zdGFsbCBEb2NrZXIgYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGFuZCB1cGxvYWQgYSBEb2NrZXIgaW1hZ2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVDb250YWluZXJBc3NldE5ldyhhc3NlbWJseURpcjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldDogQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbykge1xuXG4gIGlmIChhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIgfHwgIWFzc2V0LnJlcG9zaXRvcnlOYW1lIHx8ICFhc3NldC5pbWFnZVRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkb2NrZXIgaW1hZ2UgYXNzZXQgY29uZmlndXJhdGlvbi4gXCJyZXBvc2l0b3J5TmFtZVwiIGFuZCBcImltYWdlVGFnXCIgYXJlIHJlcXVpcmVkIGFuZCBcImltYWdlTmFtZVBhcmFtZXRlclwiIGlzIG5vdCBhbGxvd2VkYCk7XG4gIH1cblxuICBjb25zdCBjb250ZXh0UGF0aCA9IHBhdGguaXNBYnNvbHV0ZShhc3NldC5wYXRoKSA/IGFzc2V0LnBhdGggOiBwYXRoLmpvaW4oYXNzZW1ibHlEaXIsIGFzc2V0LnBhdGgpO1xuXG4gIGRlYnVnKCcg8J+RkSAgUHJlcGFyaW5nIERvY2tlciBpbWFnZSBhc3NldDonLCBjb250ZXh0UGF0aCk7XG4gIGNvbnN0IGVjciA9IGF3YWl0IHRvb2xraXRJbmZvLnByZXBhcmVFY3JSZXBvc2l0b3J5KGFzc2V0LnJlcG9zaXRvcnlOYW1lKTtcblxuICAvLyBpZiBib3RoIHJlcG8gbmFtZSBhbmQgaW1hZ2UgdGFnIGFyZSBleHBsaWNpdGx5IGRlZmluZWQsIHdlIGFzc3VtZSB0aGVcbiAgLy8gaW1hZ2UgaXMgaW1tdXRhYmxlIGFuZCBjYW4gc2tpcCBidWlsZCAmIHB1c2guXG4gIGRlYnVnKGAke2Fzc2V0LnJlcG9zaXRvcnlOYW1lfToke2Fzc2V0LmltYWdlVGFnfTogY2hlY2tpbmcgaWYgaW1hZ2UgYWxyZWFkeSBleGlzdHNgKTtcbiAgaWYgKGF3YWl0IHRvb2xraXRJbmZvLmNoZWNrRWNySW1hZ2UoYXNzZXQucmVwb3NpdG9yeU5hbWUsIGFzc2V0LmltYWdlVGFnKSkge1xuICAgIHByaW50KGAke2Fzc2V0LnJlcG9zaXRvcnlOYW1lfToke2Fzc2V0LmltYWdlVGFnfTogaW1hZ2UgYWxyZWFkeSBleGlzdHMsIHNraXBwaW5nIGJ1aWxkIGFuZCBwdXNoYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2UgdXNlIFwibGF0ZXN0XCIgZm9yIGltYWdlIHRhZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUtMS4yMS4wIGFwcHMuXG4gIGNvbnN0IGZ1bGxJbWFnZU5hbWUgPSBgJHtlY3IucmVwb3NpdG9yeVVyaX06JHthc3NldC5pbWFnZVRhZ31gO1xuXG4gIC8vIHJlbmRlciBcImRvY2tlciBidWlsZFwiIGNvbW1hbmRcblxuICBjb25zdCBidWlsZENvbW1hbmQgPSBbICdkb2NrZXInLCAnYnVpbGQnIF07XG5cbiAgYnVpbGRDb21tYW5kLnB1c2goJy0tdGFnJywgZnVsbEltYWdlTmFtZSk7XG5cbiAgaWYgKGFzc2V0LnRhcmdldCkge1xuICAgIGJ1aWxkQ29tbWFuZC5wdXNoKCctLXRhcmdldCcsIGFzc2V0LnRhcmdldCk7XG4gIH1cblxuICBpZiAoYXNzZXQuZmlsZSkge1xuICAgICAgLy8gcmVtZW1iZXIgd2UgYXNzdW1lIHRoZSBmaWxlIGlzIHJlbGF0aXZlICh3ZSB2YWxpZGF0ZSB0aGlzIGluIHRoZSBhc3NldCBjb25zdHJ1Y3RvcilcbiAgICAgIGJ1aWxkQ29tbWFuZC5wdXNoKCctLWZpbGUnLCBwYXRoLmpvaW4oY29udGV4dFBhdGgsIGFzc2V0LmZpbGUpKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgWyBrZXksIHZhbHVlIF0gb2YgT2JqZWN0LmVudHJpZXMoYXNzZXQuYnVpbGRBcmdzIHx8IHt9KSkge1xuICAgIGJ1aWxkQ29tbWFuZC5wdXNoKGAtLWJ1aWxkLWFyZ2AsIGAke2tleX09JHt2YWx1ZX1gKTtcbiAgfVxuXG4gIGJ1aWxkQ29tbWFuZC5wdXNoKGNvbnRleHRQYXRoKTtcblxuICAvLyBMb2dpbiB0byBFQ1IgYmVmb3JlIGJ1aWxkIHRvIGFsbG93IGJ1aWxkaW5nIGltYWdlcyB0aGF0IHJlZmVyZW5jZSBvdGhlciBkb2NrZXIgYXNzZXRzXG4gIHRyeSB7XG4gICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGV4ZWN1dGUgXCJkb2NrZXJcIiBpbiBvcmRlciB0byBidWlsZCBhIGNvbnRhaW5lciBhc3NldC4gUGxlYXNlIGluc3RhbGwgXCJkb2NrZXJcIiBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgYXdhaXQgc2hlbGwoYnVpbGRDb21tYW5kKTtcblxuICAvLyBUaGVyZSdzIG5vIHdheSB0byBtYWtlIHRoaXMgcXVpZXQsIHNvIHdlIGNhbid0IHVzZSBhIFBsZWFzZUhvbGQuIFByaW50IGEgaGVhZGVyIG1lc3NhZ2UuXG4gIHByaW50KGAg4oybIFB1c2hpbmcgRG9ja2VyIGltYWdlIGZvciAke2NvbnRleHRQYXRofTsgdGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdXNoJywgZnVsbEltYWdlTmFtZV0pO1xuICBkZWJ1ZyhgIPCfkZEgIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH0gcHVzaGVkLmApO1xufVxuXG4vKipcbiAqIEdldCBjcmVkZW50aWFscyBmcm9tIEVDUiBhbmQgcnVuIGRvY2tlciBsb2dpblxuICovXG5hc3luYyBmdW5jdGlvbiBkb2NrZXJMb2dpbih0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pIHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCB0b29sa2l0SW5mby5nZXRFY3JDcmVkZW50aWFscygpO1xuICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdsb2dpbicsXG4gICctLXVzZXJuYW1lJywgY3JlZGVudGlhbHMudXNlcm5hbWUsXG4gICctLXBhc3N3b3JkJywgY3JlZGVudGlhbHMucGFzc3dvcmQsXG4gIGNyZWRlbnRpYWxzLmVuZHBvaW50XSk7XG59Il19