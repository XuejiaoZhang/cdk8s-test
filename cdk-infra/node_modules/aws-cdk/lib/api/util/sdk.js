"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const https = require("https");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 *
 * @experimental
 */
class SDK {
    constructor(options = {}) {
        /**
         * Default retry options for SDK clients
         *
         * Biggest bottleneck is CloudFormation, with a 1tps call rate. We want to be
         * a little more tenacious than the defaults, and with a little more breathing
         * room between calls (defaults are {retries=3, base=100}).
         *
         * I've left this running in a tight loop for an hour and the throttle errors
         * haven't escaped the retry mechanism.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        this.configureSDKHttpOptions(options);
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegionGetter(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    cloudFormation(account, region, mode) {
        return this.service(AWS.CloudFormation, account, region, mode);
    }
    ec2(account, region, mode) {
        return this.service(AWS.EC2, account, region, mode);
    }
    ssm(account, region, mode) {
        return this.service(AWS.SSM, account, region, mode);
    }
    s3(account, region, mode) {
        return this.service(AWS.S3, account, region, mode);
    }
    route53(account, region, mode) {
        return this.service(AWS.Route53, account, region, mode);
    }
    ecr(account, region, mode) {
        return this.service(AWS.ECR, account, region, mode);
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegionGetter(this.profile)();
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
    async service(ctor, account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new ctor({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async resolveEnvironment(account, region) {
        if (region === cxapi.UNKNOWN_REGION) {
            region = await this.defaultRegion();
        }
        if (account === cxapi.UNKNOWN_ACCOUNT) {
            account = await this.defaultAccount();
        }
        if (!region) {
            throw new Error(`AWS region must be configured either when you configure your CDK stack or through the environment`);
        }
        if (!account) {
            throw new Error(`Unable to resolve AWS account to use. It must be either configured when you define your CDK or through the environment`);
        }
        const environment = {
            region, account, name: cxapi.EnvironmentUtils.format(account, region)
        };
        return environment;
    }
    configureSDKHttpOptions(options) {
        const config = {};
        config.httpOptions = {};
        let userAgent = options.userAgent;
        if (userAgent == null) {
            // Find the package.json from the main toolkit
            const pkg = require.main.require('../package.json');
            userAgent = `${pkg.name}/${pkg.version}`;
        }
        config.customUserAgent = userAgent;
        const proxyAddress = options.proxyAddress || httpsProxyFromEnvironment();
        const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
        if (proxyAddress && caBundlePath) {
            throw new Error(`At the moment, cannot specify Proxy (${proxyAddress}) and CA Bundle (${caBundlePath}) at the same time. See https://github.com/aws/aws-cdk/issues/5804`);
            // Maybe it's possible after all, but I've been staring at
            // https://github.com/TooTallNate/node-proxy-agent/blob/master/index.js#L79
            // a while now trying to figure out what to pass in so that the underlying Agent
            // object will get the 'ca' argument. It's not trivial and I don't want to risk it.
        }
        if (proxyAddress) { // Ignore empty string on purpose
            // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
            logging_1.debug('Using proxy server: %s', proxyAddress);
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            const ProxyAgent = require('proxy-agent');
            config.httpOptions.agent = new ProxyAgent(proxyAddress);
        }
        if (caBundlePath) {
            logging_1.debug('Using CA bundle path: %s', caBundlePath);
            config.httpOptions.agent = new https.Agent({
                ca: readIfPossible(caBundlePath)
            });
        }
        AWS.config.update(config);
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount || awsAccountId === cxapi.UNKNOWN_ACCOUNT) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region() }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (await fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 *
 * Returns a function that can be invoked to retrieve the actual region value
 * (used to be just a promise, but that would lead to firing off a failing
 * operation and if it was never awaited NodeJS would complain).
 */
function getCLICompatibleDefaultRegionGetter(profile) {
    let retrieved = false;
    let region;
    return async () => {
        if (!retrieved) {
            profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
            // Defaults inside constructor
            const toCheck = [
                { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
                { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
            ];
            region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
                process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
            while (!region && toCheck.length > 0) {
                const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
                const section = await configFile.getProfile(profile);
                region = section && section.region;
            }
            if (!region) {
                const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
                logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}`);
            }
            retrieved = true;
        }
        return region;
    };
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUUvQiwrQ0FBK0M7QUFDL0MsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QiwyQ0FBc0M7QUFDdEMseUNBQTBDO0FBRTFDLG1EQUF3RDtBQUN4RCxpREFBK0M7QUE0RC9DOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFhLEdBQUc7SUFpQmQsWUFBWSxVQUFzQixFQUFFO1FBWnBDOzs7Ozs7Ozs7V0FTRztRQUNjLGlCQUFZLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFDLENBQUM7UUFHakYsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO1FBRS9CLE1BQU0seUJBQXlCLEdBQUcsbUNBQW1DLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGlCQUFpQixDQUFDLHlCQUF5QixFQUFFLG1DQUFtQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQzdILElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7SUFFTSxjQUFjLENBQUMsT0FBMkIsRUFBRSxNQUEwQixFQUFFLElBQVU7UUFDdkYsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FB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QUMsbUJBQW1CLEdBQUcsR0FBRyxDQUFDO0tBQ3ZDO0FBQ0gsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGNBQWMsQ0FBQyxRQUFnQjtJQUN0QyxJQUFJO1FBQ0YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFNBQVMsQ0FBQztTQUFFO1FBQ3ZELE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN6RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsZUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1QsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUMsRUFBVSxFQUFFLENBQXFCO0lBQ3JELE9BQU8sQ0FBQyxLQUFLLFNBQVMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQztBQUNoRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IFNlcnZpY2VDb25maWd1cmF0aW9uT3B0aW9ucyB9IGZyb20gJ2F3cy1zZGsvbGliL3NlcnZpY2UnO1xuaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi8uLi9wbHVnaW4nO1xuaW1wb3J0IHsgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlLCBNb2RlIH0gZnJvbSAnLi4vYXdzLWF1dGgvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQWNjb3VudEFjY2Vzc0tleUNhY2hlIH0gZnJvbSAnLi9hY2NvdW50LWNhY2hlJztcbmltcG9ydCB7IFNoYXJlZEluaUZpbGUgfSBmcm9tICcuL3Nka19pbmlfZmlsZSc7XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIElTREsge1xuICBjbG91ZEZvcm1hdGlvbihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24+O1xuXG4gIGVjMihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPjtcblxuICBzc20oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlNTTT47XG5cbiAgczMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlMzPjtcblxuICByb3V0ZTUzKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5Sb3V0ZTUzPjtcblxuICBlY3IoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkVDUj47XG5cbiAgZGVmYXVsdFJlZ2lvbigpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD47XG5cbiAgZGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNES09wdGlvbnMge1xuICAvKipcbiAgICogUHJvZmlsZSBuYW1lIHRvIHVzZVxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBwcm9maWxlXG4gICAqL1xuICBwcm9maWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcm94eSBhZGRyZXNzIHRvIHVzZVxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBwcm94eVxuICAgKi9cbiAgcHJveHlBZGRyZXNzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCB0cnkgaW5zdGFuY2UgY3JlZGVudGlhbHNcbiAgICpcbiAgICogVHJ1ZS9mYWxzZSB0byBmb3JjZS9kaXNhYmxlLiBEZWZhdWx0IGlzIHRvIGd1ZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBBdXRvbWF0aWNhbGx5IGRldGVybWluZS5cbiAgICovXG4gIGVjMmNyZWRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQSBwYXRoIHRvIGEgY2VydGlmaWNhdGUgYnVuZGxlIHRoYXQgY29udGFpbnMgYSBjZXJ0IHRvIGJlIHRydXN0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIGNlcnRpZmljYXRlIGJ1bmRsZVxuICAgKi9cbiAgY2FCdW5kbGVQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VzdG9tIHN1ZXIgYWdlbnQgdG8gdXNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIDxwYWNrYWdlLW5hbWU+LzxwYWNrYWdlLXZlcnNpb24+XG4gICAqL1xuICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU291cmNlIGZvciBTREsgY2xpZW50IG9iamVjdHNcbiAqXG4gKiBDcmVkZW50aWFscyBhcmUgZmlyc3Qgb2J0YWluZWQgZnJvbSB0aGUgU0RLIGRlZmF1bHRzICh1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHRoZVxuICogfi8uYXdzL3tjb25maWcsY3JlZGVudGlhbHN9IGZpbGVzKS5cbiAqXG4gKiBJZiB0aG9zZSBkb24ndCBzdWZmaWNlLCBhIGxpc3Qgb2YgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlcyBpcyBpbnRlcnJvZ2F0ZWQgZm9yIGFjY2Vzc1xuICogdG8gdGhlIHJlcXVlc3RlZCBhY2NvdW50LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIFNESyBpbXBsZW1lbnRzIElTREsge1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRBd3NBY2NvdW50OiBEZWZhdWx0QVdTQWNjb3VudDtcbiAgcHJpdmF0ZSByZWFkb25seSBjcmVkZW50aWFsc0NhY2hlOiBDcmVkZW50aWFsc0NhY2hlO1xuICBwcml2YXRlIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmV0cnkgb3B0aW9ucyBmb3IgU0RLIGNsaWVudHNcbiAgICpcbiAgICogQmlnZ2VzdCBib3R0bGVuZWNrIGlzIENsb3VkRm9ybWF0aW9uLCB3aXRoIGEgMXRwcyBjYWxsIHJhdGUuIFdlIHdhbnQgdG8gYmVcbiAgICogYSBsaXR0bGUgbW9yZSB0ZW5hY2lvdXMgdGhhbiB0aGUgZGVmYXVsdHMsIGFuZCB3aXRoIGEgbGl0dGxlIG1vcmUgYnJlYXRoaW5nXG4gICAqIHJvb20gYmV0d2VlbiBjYWxscyAoZGVmYXVsdHMgYXJlIHtyZXRyaWVzPTMsIGJhc2U9MTAwfSkuXG4gICAqXG4gICAqIEkndmUgbGVmdCB0aGlzIHJ1bm5pbmcgaW4gYSB0aWdodCBsb29wIGZvciBhbiBob3VyIGFuZCB0aGUgdGhyb3R0bGUgZXJyb3JzXG4gICAqIGhhdmVuJ3QgZXNjYXBlZCB0aGUgcmV0cnkgbWVjaGFuaXNtLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDYsIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDMwMCB9fTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTREtPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGU7XG5cbiAgICBjb25zdCBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyID0gbWFrZUNMSUNvbXBhdGlibGVDcmVkZW50aWFsUHJvdmlkZXIob3B0aW9ucy5wcm9maWxlLCBvcHRpb25zLmVjMmNyZWRzKTtcblxuICAgIHRoaXMuY29uZmlndXJlU0RLSHR0cE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlZmF1bHRBd3NBY2NvdW50ID0gbmV3IERlZmF1bHRBV1NBY2NvdW50KGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIsIGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uR2V0dGVyKHRoaXMucHJvZmlsZSkpO1xuICAgIHRoaXMuY3JlZGVudGlhbHNDYWNoZSA9IG5ldyBDcmVkZW50aWFsc0NhY2hlKHRoaXMuZGVmYXVsdEF3c0FjY291bnQsIGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIpO1xuICB9XG5cbiAgcHVibGljIGNsb3VkRm9ybWF0aW9uKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UoQVdTLkNsb3VkRm9ybWF0aW9uLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIGVjMihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZShBV1MuRUMyLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIHNzbShhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuU1NNPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZShBV1MuU1NNLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIHMzKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5TMz4ge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UoQVdTLlMzLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIHJvdXRlNTMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+IHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlKEFXUy5Sb3V0ZTUzLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIGVjcihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUNSPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZShBV1MuRUNSLCBhY2NvdW50LCByZWdpb24sIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlZmF1bHRSZWdpb24oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIodGhpcy5wcm9maWxlKSgpO1xuICB9XG5cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF3c0FjY291bnQuZ2V0KCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlcnZpY2U8VCBleHRlbmRzIEFXUy5TZXJ2aWNlPihcbiAgICBjdG9yOiBuZXcgPE8gZXh0ZW5kcyBTZXJ2aWNlQ29uZmlndXJhdGlvbk9wdGlvbnM+KG9wdHM/OiBPKSA9PiBULFxuICAgIGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBtb2RlOiBNb2RlKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgY3Rvcih7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVzb2x2ZUVudmlyb25tZW50KGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsICkge1xuICAgIGlmIChyZWdpb24gPT09IGN4YXBpLlVOS05PV05fUkVHSU9OKSB7XG4gICAgICByZWdpb24gPSBhd2FpdCB0aGlzLmRlZmF1bHRSZWdpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoYWNjb3VudCA9PT0gY3hhcGkuVU5LTk9XTl9BQ0NPVU5UKSB7XG4gICAgICBhY2NvdW50ID0gYXdhaXQgdGhpcy5kZWZhdWx0QWNjb3VudCgpO1xuICAgIH1cblxuICAgIGlmICghcmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFXUyByZWdpb24gbXVzdCBiZSBjb25maWd1cmVkIGVpdGhlciB3aGVuIHlvdSBjb25maWd1cmUgeW91ciBDREsgc3RhY2sgb3IgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnRgKTtcbiAgICB9XG5cbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgQVdTIGFjY291bnQgdG8gdXNlLiBJdCBtdXN0IGJlIGVpdGhlciBjb25maWd1cmVkIHdoZW4geW91IGRlZmluZSB5b3VyIENESyBvciB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudGApO1xuICAgIH1cblxuICAgIGNvbnN0IGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCA9IHtcbiAgICAgIHJlZ2lvbiwgYWNjb3VudCwgbmFtZTogY3hhcGkuRW52aXJvbm1lbnRVdGlscy5mb3JtYXQoYWNjb3VudCwgcmVnaW9uKVxuICAgIH07XG5cbiAgICByZXR1cm4gZW52aXJvbm1lbnQ7XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZ3VyZVNES0h0dHBPcHRpb25zKG9wdGlvbnM6IFNES09wdGlvbnMpIHtcbiAgICBjb25zdCBjb25maWc6IHtbazogc3RyaW5nXTogYW55fSA9IHt9O1xuICAgIGNvbmZpZy5odHRwT3B0aW9ucyA9IHt9O1xuXG4gICAgbGV0IHVzZXJBZ2VudCA9IG9wdGlvbnMudXNlckFnZW50O1xuICAgIGlmICh1c2VyQWdlbnQgPT0gbnVsbCkge1xuICAgICAgLy8gRmluZCB0aGUgcGFja2FnZS5qc29uIGZyb20gdGhlIG1haW4gdG9vbGtpdFxuICAgICAgY29uc3QgcGtnID0gKHJlcXVpcmUubWFpbiBhcyBhbnkpLnJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuICAgICAgdXNlckFnZW50ID0gYCR7cGtnLm5hbWV9LyR7cGtnLnZlcnNpb259YDtcbiAgICB9XG4gICAgY29uZmlnLmN1c3RvbVVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcblxuICAgIGNvbnN0IHByb3h5QWRkcmVzcyA9IG9wdGlvbnMucHJveHlBZGRyZXNzIHx8IGh0dHBzUHJveHlGcm9tRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCBjYUJ1bmRsZVBhdGggPSBvcHRpb25zLmNhQnVuZGxlUGF0aCB8fCBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTtcblxuICAgIGlmIChwcm94eUFkZHJlc3MgJiYgY2FCdW5kbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0IHRoZSBtb21lbnQsIGNhbm5vdCBzcGVjaWZ5IFByb3h5ICgke3Byb3h5QWRkcmVzc30pIGFuZCBDQSBCdW5kbGUgKCR7Y2FCdW5kbGVQYXRofSkgYXQgdGhlIHNhbWUgdGltZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvNTgwNGApO1xuICAgICAgLy8gTWF5YmUgaXQncyBwb3NzaWJsZSBhZnRlciBhbGwsIGJ1dCBJJ3ZlIGJlZW4gc3RhcmluZyBhdFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Rvb1RhbGxOYXRlL25vZGUtcHJveHktYWdlbnQvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDc5XG4gICAgICAvLyBhIHdoaWxlIG5vdyB0cnlpbmcgdG8gZmlndXJlIG91dCB3aGF0IHRvIHBhc3MgaW4gc28gdGhhdCB0aGUgdW5kZXJseWluZyBBZ2VudFxuICAgICAgLy8gb2JqZWN0IHdpbGwgZ2V0IHRoZSAnY2EnIGFyZ3VtZW50LiBJdCdzIG5vdCB0cml2aWFsIGFuZCBJIGRvbid0IHdhbnQgdG8gcmlzayBpdC5cbiAgICB9XG5cbiAgICBpZiAocHJveHlBZGRyZXNzKSB7IC8vIElnbm9yZSBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuICAgICAgLy8gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9ibG9ncy9kZXZlbG9wZXIvdXNpbmctdGhlLWF3cy1zZGstZm9yLWphdmFzY3JpcHQtZnJvbS1iZWhpbmQtYS1wcm94eS9cbiAgICAgIGRlYnVnKCdVc2luZyBwcm94eSBzZXJ2ZXI6ICVzJywgcHJveHlBZGRyZXNzKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICBjb25zdCBQcm94eUFnZW50OiBhbnkgPSByZXF1aXJlKCdwcm94eS1hZ2VudCcpO1xuICAgICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IFByb3h5QWdlbnQocHJveHlBZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKGNhQnVuZGxlUGF0aCkge1xuICAgICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIGNhQnVuZGxlUGF0aCk7XG4gICAgICBjb25maWcuaHR0cE9wdGlvbnMuYWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoe1xuICAgICAgICBjYTogcmVhZElmUG9zc2libGUoY2FCdW5kbGVQYXRoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQVdTLmNvbmZpZy51cGRhdGUoY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIENhY2hlIGZvciBjcmVkZW50aWFsIHByb3ZpZGVycy5cbiAqXG4gKiBHaXZlbiBhbiBhY2NvdW50IGFuZCBhbiBvcGVyYXRpbmcgbW9kZSAocmVhZCBvciB3cml0ZSkgd2lsbCByZXR1cm4gYW5cbiAqIGFwcHJvcHJpYXRlIGNyZWRlbnRpYWwgcHJvdmlkZXIgZm9yIGNyZWRlbnRpYWxzIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC4gVGhlXG4gKiBjcmVkZW50aWFsIHByb3ZpZGVyIHdpbGwgYmUgY2FjaGVkIHNvIHRoYXQgbXVsdGlwbGUgQVdTIGNsaWVudHMgZm9yIHRoZSBzYW1lXG4gKiBlbnZpcm9ubWVudCB3aWxsIG5vdCBtYWtlIG11bHRpcGxlIG5ldHdvcmsgY2FsbHMgdG8gb2J0YWluIGNyZWRlbnRpYWxzLlxuICpcbiAqIFdpbGwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgaWYgdGhleSBhcmUgZm9yIHRoZSByaWdodCBhY2NvdW50OyBvdGhlcndpc2UsXG4gKiBhbGwgbG9hZGVkIGNyZWRlbnRpYWwgcHJvdmlkZXIgcGx1Z2lucyB3aWxsIGJlIHRyaWVkIHRvIG9idGFpbiBjcmVkZW50aWFsc1xuICogZm9yIHRoZSBnaXZlbiBhY2NvdW50LlxuICovXG5jbGFzcyBDcmVkZW50aWFsc0NhY2hlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZToge1trZXk6IHN0cmluZ106IEFXUy5DcmVkZW50aWFsc30gPSB7fTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0QXdzQWNjb3VudDogRGVmYXVsdEFXU0FjY291bnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyOiBQcm9taXNlPEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbj4pIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoYXdzQWNjb3VudElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIGNvbnN0IGtleSA9IGAke2F3c0FjY291bnRJZH0tJHttb2RlfWA7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMuY2FjaGUpKSB7XG4gICAgICB0aGlzLmNhY2hlW2tleV0gPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKGF3c0FjY291bnRJZCwgbW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlW2tleV07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldENyZWRlbnRpYWxzKGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICAvLyBJZiByZXF1ZXN0ZWQgYWNjb3VudCBpcyB1bmRlZmluZWQgb3IgZXF1YWwgdG8gZGVmYXVsdCBhY2NvdW50LCB1c2UgZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlci5cbiAgICAvLyAoTm90ZSB0aGF0IHdlIGlnbm9yZSB0aGUgbW9kZSBpbiB0aGlzIGNhc2UsIGlmIHlvdSBwcmVsb2FkZWQgY3JlZGVudGlhbHMgdGhleSBiZXR0ZXIgYmUgY29ycmVjdCEpXG4gICAgY29uc3QgZGVmYXVsdEFjY291bnQgPSBhd2FpdCB0aGlzLmRlZmF1bHRBd3NBY2NvdW50LmdldCgpO1xuICAgIGlmICghYXdzQWNjb3VudElkIHx8IGF3c0FjY291bnRJZCA9PT0gZGVmYXVsdEFjY291bnQgfHwgYXdzQWNjb3VudElkID09PSBjeGFwaS5VTktOT1dOX0FDQ09VTlQpIHtcbiAgICAgIGRlYnVnKGBVc2luZyBkZWZhdWx0IEFXUyBTREsgY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG5cbiAgICAgIC8vIENyZWRlbnRpYWxQcm92aWRlckNoYWluIGV4dGVuZHMgQ3JlZGVudGlhbHMsIGJ1dCB0aGF0IGlzIGEgbGllLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2lzc3Vlcy8yMjM1XG4gICAgICAvLyBDYWxsIHJlc29sdmUoKSBpbnN0ZWFkLlxuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIpLnJlc29sdmVQcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJpZWRTb3VyY2VzOiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VbXSA9IFtdO1xuICAgIC8vIE90aGVyd2lzZSwgaW5zcGVjdCB0aGUgdmFyaW91cyBjcmVkZW50aWFsIHNvdXJjZXMgd2UgaGF2ZVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcykge1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmlzQXZhaWxhYmxlKCkpKSB7XG4gICAgICAgIGRlYnVnKCdDcmVkZW50aWFscyBzb3VyY2UgJXMgaXMgbm90IGF2YWlsYWJsZSwgaWdub3JpbmcgaXQuJywgc291cmNlLm5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyaWVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBpZiAoIShhd2FpdCBzb3VyY2UuY2FuUHJvdmlkZUNyZWRlbnRpYWxzKGF3c0FjY291bnRJZCkpKSB7IGNvbnRpbnVlOyB9XG4gICAgICBkZWJ1ZyhgVXNpbmcgJHtzb3VyY2UubmFtZX0gY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG4gICAgICBjb25zdCBwcm92aWRlck9yQ3JlZHMgPSBhd2FpdCBzb3VyY2UuZ2V0UHJvdmlkZXIoYXdzQWNjb3VudElkLCBtb2RlKTtcblxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIHRoZSBwbHVnaW4gcmV0dXJucyBhIFByb3ZpZGVyQ2hhaW4sIHJlc29sdmUgdGhhdCBjaGFpbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCBtdXN0IGhhdmUgcmV0dXJuZWQgY3JlZGVudGlhbHMuXG4gICAgICBpZiAoKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAocHJvdmlkZXJPckNyZWRzIGFzIGFueSkucmVzb2x2ZVByb21pc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm92aWRlck9yQ3JlZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZU5hbWVzID0gWydkZWZhdWx0IGNyZWRlbnRpYWxzJ10uY29uY2F0KHRyaWVkU291cmNlcy5tYXAocyA9PiBzLm5hbWUpKS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCB0byBwZXJmb3JtIEFXUyBjYWxscyBmb3IgYWNjb3VudCAke2F3c0FjY291bnRJZH0sIGJ1dCBubyBjcmVkZW50aWFscyBmb3VuZC4gVHJpZWQ6ICR7c291cmNlTmFtZXN9LmApO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdG8gcmV0cmlldmUgdGhlIGFjY291bnQgZm9yIGRlZmF1bHQgY3JlZGVudGlhbHMgYW5kIGNhY2hlIGl0LlxuICpcbiAqIFVzZXMgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXIgdG8gb2J0YWluIGNyZWRlbnRpYWxzIChpZiBhdmFpbGFibGUpLFxuICogYW5kIHVzZXMgdGhvc2UgY3JlZGVudGlhbHMgdG8gY2FsbCBTVFMgdG8gcmVxdWVzdCB0aGUgY3VycmVudCBhY2NvdW50IElELlxuICpcbiAqIFRoZSBjcmVkZW50aWFscyA9PiBhY2NvdW50SWQgbG9va3VwIGlzIGNhY2hlZCBvbiBkaXNrLCBzaW5jZSBpdCdzXG4gKiBndWFyYW50ZWVkIHRoYXQgaWd2ZW4gYWNjZXNzIGtleSB3aWxsIGFsd2F5cyByZW1haW4gZm9yIHRoZSBzYW1lIGFjY291bnQuXG4gKi9cbmNsYXNzIERlZmF1bHRBV1NBY2NvdW50IHtcbiAgcHJpdmF0ZSBkZWZhdWx0QWNjb3VudEZldGNoZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWZhdWx0QWNjb3VudElkPzogc3RyaW5nID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIHJlYWRvbmx5IGFjY291bnRDYWNoZSA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENyZWRlbnRpYWxzUHJvdmlkZXI6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluPixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVnaW9uOiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYWNjb3VudFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5kZWZhdWx0QWNjb3VudEZldGNoZWQpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEFjY291bnRJZCA9IGF3YWl0IHRoaXMubG9va3VwRGVmYXVsdEFjY291bnQoKTtcbiAgICAgIHRoaXMuZGVmYXVsdEFjY291bnRGZXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEFjY291bnRJZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9va3VwRGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUganVzdCBpcyAqTk8qIHdheSB0byBkbyBBc3N1bWVSb2xlIGNyZWRlbnRpYWxzIGFzIGxvbmcgYXMgQVdTX1NES19MT0FEX0NPTkZJRyBpcyBub3Qgc2V0LiBUaGUgU0RLXG4gICAgICAvLyBjcmFzaCBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCB0aG91Z2guIFNvIHNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgd2UgY2FuIGZpbmQgdGhhdCBmaWxlLlxuICAgICAgYXdhaXQgc2V0Q29uZmlnVmFyaWFibGUoKTtcblxuICAgICAgZGVidWcoJ1Jlc29sdmluZyBkZWZhdWx0IGNyZWRlbnRpYWxzJyk7XG4gICAgICBjb25zdCBjcmVkZW50aWFsUHJvdmlkZXIgPSBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCBjcmVkZW50aWFsUHJvdmlkZXIucmVzb2x2ZVByb21pc2UoKTtcblxuICAgICAgY29uc3QgYWNjZXNzS2V5SWQgPSBjcmVkcy5hY2Nlc3NLZXlJZDtcbiAgICAgIGlmICghYWNjZXNzS2V5SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBBV1MgY3JlZGVudGlhbHMgKHNldHVwIHdpdGggXCJhd3MgY29uZmlndXJlXCIpJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IGF3YWl0IHRoaXMuYWNjb3VudENhY2hlLmZldGNoKGNyZWRzLmFjY2Vzc0tleUlkLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgb25lLCByZXNvbHZlIGZyb20gU1RTIGFuZCBzdG9yZSBpbiBjYWNoZS5cbiAgICAgICAgZGVidWcoJ0xvb2tpbmcgdXAgZGVmYXVsdCBhY2NvdW50IElEIGZyb20gU1RTJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBBV1MuU1RTKHsgY3JlZGVudGlhbHM6IGNyZWRzLCByZWdpb246IGF3YWl0IHRoaXMucmVnaW9uKCkgfSkuZ2V0Q2FsbGVySWRlbnRpdHkoKS5wcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IGFpZCA9IHJlc3VsdC5BY2NvdW50O1xuICAgICAgICBpZiAoIWFpZCkge1xuICAgICAgICAgIGRlYnVnKCdTVFMgZGlkblxcJ3QgcmV0dXJuIGFuIGFjY291bnQgSUQnKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdEZWZhdWx0IGFjY291bnQgSUQ6JywgYWlkKTtcbiAgICAgICAgcmV0dXJuIGFpZDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYWNjb3VudElkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdVbmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IEFXUyBhY2NvdW50IChkaWQgeW91IGNvbmZpZ3VyZSBcImF3cyBjb25maWd1cmVcIj8pOicsIGUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBBV1MgQ0xJLWNvbXBhdGlibGUgY3JlZGVudGlhbCBjaGFpbiBwcm92aWRlclxuICpcbiAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgZGVmYXVsdCBjcmVkZW50aWFsIHByb3ZpZGVyIGNoYWluIGNyZWF0ZWQgYnkgdGhlIFNES1xuICogZXhjZXB0IGl0IGFsc28gYWNjZXB0cyB0aGUgcHJvZmlsZSBhcmd1bWVudCBpbiB0aGUgY29uc3RydWN0b3IgKG5vdCBqdXN0IGZyb21cbiAqIHRoZSBlbnZpcm9ubWVudCkuXG4gKlxuICogVG8gbWltaWMgdGhlIEFXUyBDTEkgYmVoYXZpb3I6XG4gKlxuICogLSB3ZSBkZWZhdWx0IHRvIH4vLmF3cy9jcmVkZW50aWFscyBpZiBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgY3JlZGVudGlhbHNcbiAqIGZpbGUgbG9jYXRpb24gaXMgbm90IGdpdmVuIChTREsgZXhwZWN0cyBleHBsaWNpdCBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIG5hbWUpLlxuICogLSBBV1NfREVGQVVMVF9QUk9GSUxFIGlzIGFsc28gaW5zcGVjdGVkIGZvciBwcm9maWxlIG5hbWUgKG5vdCBqdXN0IEFXU19QUk9GSUxFKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFrZUNMSUNvbXBhdGlibGVDcmVkZW50aWFsUHJvdmlkZXIocHJvZmlsZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBlYzJjcmVkczogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAvLyBOZWVkIHRvIGNvbnN0cnVjdCBmaWxlbmFtZSBvdXJzZWx2ZXMsIHdpdGhvdXQgYXBwcm9wcmlhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIC8vIG5vIGRlZmF1bHRzIHVzZWQgYnkgSlMgU0RLLlxuICBjb25zdCBmaWxlbmFtZSA9IHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB8fCBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCAnLmF3cycsICdjcmVkZW50aWFscycpO1xuXG4gIGNvbnN0IHNvdXJjZXMgPSBbXG4gICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKSxcbiAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpLFxuICBdO1xuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhmaWxlbmFtZSkpIHtcbiAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoeyBwcm9maWxlLCBmaWxlbmFtZSB9KSk7XG4gIH1cblxuICBpZiAoaGFzRWNzQ3JlZGVudGlhbHMoKSkge1xuICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgaWY6IGRvbid0IGdldCBFQzIgY3JlZHMgaWYgd2Ugc2hvdWxkIGhhdmUgZ290dGVuIEVDUyBjcmVkcy0tRUNTIGluc3RhbmNlcyBhbHNvXG4gICAgLy8gcnVuIG9uIEVDMiBib3hlcyBidXQgdGhlIGNyZWRzIHJlcHJlc2VudCBzb21ldGhpbmcgZGlmZmVyZW50LiBTYW1lIGJlaGF2aW9yIGFzXG4gICAgLy8gdXBzdHJlYW0gY29kZS5cblxuICAgIGlmIChlYzJjcmVkcyA9PT0gdW5kZWZpbmVkKSB7IGVjMmNyZWRzID0gYXdhaXQgaGFzRWMyQ3JlZGVudGlhbHMoKTsgfVxuXG4gICAgaWYgKGVjMmNyZWRzKSB7XG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzKCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKHNvdXJjZXMpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVmYXVsdCByZWdpb24gaW4gYSBDTEktY29tcGF0aWJsZSB3YXlcbiAqXG4gKiBNb3N0bHkgY29waWVkIGZyb20gbm9kZV9sb2FkZXIuanMsIGJ1dCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gKlxuICogLSBUYWtlcyBhIHJ1bnRpbWUgcHJvZmlsZSBuYW1lIHRvIGxvYWQgdGhlIHJlZ2lvbiBmcm9tLCBub3QganVzdCBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICogICB2YXJpYWJsZXMgYXQgcHJvY2VzcyBzdGFydC5cbiAqIC0gV2UgaGF2ZSBuZWVkZWQgdG8gY3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgU2hhcmVkSW5pRmlsZSBjbGFzcyBiZWNhdXNlIHRoZVxuICogICBpbXBsZW1lbnRhdGlvbiBpbiAnYXdzLXNkaycgaXMgcHJpdmF0ZSAoYW5kIHRoZSBkZWZhdWx0IHVzZSBvZiBpdCBpbiB0aGVcbiAqICAgU0RLIGRvZXMgbm90IGFsbG93IHVzIHRvIHNwZWNpZnkgYSBwcm9maWxlIGF0IHJ1bnRpbWUpLlxuICogLSBBV1NfREVGQVVMVF9QUk9GSUxFIGFuZCBBV1NfREVGQVVMVF9SRUdJT04gYXJlIGFsc28gdXNlZCBhcyBlbnZpcm9ubWVudFxuICogICB2YXJpYWJsZXMgdG8gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJlZ2lvbi5cbiAqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgaW52b2tlZCB0byByZXRyaWV2ZSB0aGUgYWN0dWFsIHJlZ2lvbiB2YWx1ZVxuICogKHVzZWQgdG8gYmUganVzdCBhIHByb21pc2UsIGJ1dCB0aGF0IHdvdWxkIGxlYWQgdG8gZmlyaW5nIG9mZiBhIGZhaWxpbmdcbiAqIG9wZXJhdGlvbiBhbmQgaWYgaXQgd2FzIG5ldmVyIGF3YWl0ZWQgTm9kZUpTIHdvdWxkIGNvbXBsYWluKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIocHJvZmlsZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IHJldHJpZXZlZCA9IGZhbHNlO1xuICBsZXQgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFyZXRyaWV2ZWQpIHtcbiAgICAgIHByb2ZpbGUgPSBwcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvLyBEZWZhdWx0cyBpbnNpZGUgY29uc3RydWN0b3JcbiAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXG4gICAgICAgIHtmaWxlbmFtZTogcHJvY2Vzcy5lbnYuQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIH0sXG4gICAgICAgIHtpc0NvbmZpZzogdHJ1ZSwgZmlsZW5hbWU6IHByb2Nlc3MuZW52LkFXU19DT05GSUdfRklMRX0sXG4gICAgICBdO1xuXG4gICAgICByZWdpb24gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9SRUdJT04gfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9ERUZBVUxUX1JFR0lPTjtcblxuICAgICAgd2hpbGUgKCFyZWdpb24gJiYgdG9DaGVjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0ZpbGUgPSBuZXcgU2hhcmVkSW5pRmlsZSh0b0NoZWNrLnNoaWZ0KCkpO1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gYXdhaXQgY29uZmlnRmlsZS5nZXRQcm9maWxlKHByb2ZpbGUpO1xuICAgICAgICByZWdpb24gPSBzZWN0aW9uICYmIHNlY3Rpb24ucmVnaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICBjb25zdCB1c2VkUHJvZmlsZSA9ICFwcm9maWxlID8gJycgOiBgIChwcm9maWxlOiBcIiR7cHJvZmlsZX1cIilgO1xuICAgICAgICBkZWJ1ZyhgVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGZyb20gZW52aXJvbm1lbnQgb3IgQVdTIGNvbmZpZ3VyYXRpb24ke3VzZWRQcm9maWxlfWApO1xuICAgICAgfVxuXG4gICAgICByZXRyaWV2ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG4gIH07XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSBjb25maWd1cmVkIEhUVFBTIHByb3h5IGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gaHR0cHNQcm94eUZyb21FbnZpcm9ubWVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkhUVFBTX1BST1hZKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBTX1BST1hZO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIGEgQ0EgY2VydGlmaWNhdGUgYnVuZGxlIHBhdGggdG8gYmUgcGFzc2VkIGludG8gdGhlIFNESy5cbiAqL1xuZnVuY3Rpb24gY2FCdW5kbGVQYXRoRnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5hd3NfY2FfYnVuZGxlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGU7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkFXU19DQV9CVU5ETEUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGl0IGxvb2tzIGxpa2Ugd2UnbGwgaGF2ZSBFQ1MgY3JlZGVudGlhbHMgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGhhc0Vjc0NyZWRlbnRpYWxzKCkge1xuICByZXR1cm4gKEFXUy5FQ1NDcmVkZW50aWFscy5wcm90b3R5cGUgYXMgYW55KS5pc0NvbmZpZ3VyZWRGb3JFY3NDcmVkZW50aWFscygpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBoYXNFYzJDcmVkZW50aWFscygpIHtcbiAgZGVidWcoXCJEZXRlcm1pbmluZyB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZS5cIik7XG5cbiAgbGV0IGluc3RhbmNlID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvV2luZG93c0d1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHV0aWwucHJvbWlzaWZ5KGNoaWxkX3Byb2Nlc3MuZXhlYykoJ3dtaWMgcGF0aCB3aW4zMl9jb21wdXRlcnN5c3RlbXByb2R1Y3QgZ2V0IHV1aWQnLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIC8vIG91dHB1dCBsb29rcyBsaWtlXG4gICAgLy8gIFVVSURcbiAgICAvLyAgRUMyQUUxNDUtRDFEQy0xM0IyLTk0RUQtMDEyMzRBQkNERUZcbiAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgaW5zdGFuY2UgPSBsaW5lcy5zb21lKHggPT4gbWF0Y2hlc1JlZ2V4KC9eZWMyL2ksIHgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9Vc2VyR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PFtzdHJpbmcsIFJlZ0V4cF0+ID0gW1xuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBYZW4gaHlwZXJ2aXNvciBiYXNlZCBpbnN0YW5jZXMgKHByZS01dGggZ2VuKVxuICAgICAgWycvc3lzL2h5cGVydmlzb3IvdXVpZCcsIC9eZWMyL2ldLFxuXG4gICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIG5ldyBIeXBlcnZpc29yICg1dGgtZ2VuIGluc3RhbmNlcyBhbmQgaGlnaGVyKVxuICAgICAgLy8gQ2FuJ3QgdXNlIHRoZSBhZHZlcnRpc2VkIGZpbGUgJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3V1aWQnIGJlY2F1c2UgaXQgcmVxdWlyZXMgcm9vdCB0byByZWFkLlxuICAgICAgLy8gSW5zdGVhZCwgc3lzX3ZlbmRvciBjb250YWlucyBzb21ldGhpbmcgbGlrZSAnQW1hem9uIEVDMicuXG4gICAgICBbJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9zeXNfdmVuZG9yJywgL2VjMi9pXSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2ZpbGUsIHJlXSBvZiBmaWxlcykge1xuICAgICAgaWYgKG1hdGNoZXNSZWdleChyZSwgcmVhZElmUG9zc2libGUoZmlsZSkpKSB7XG4gICAgICAgIGluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVidWcoaW5zdGFuY2UgPyAnTG9va3MgbGlrZSBFQzIgaW5zdGFuY2UuJyA6ICdEb2VzIG5vdCBsb29rIGxpa2UgRUMyIGluc3RhbmNlLicpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldENvbmZpZ1ZhcmlhYmxlKCkge1xuICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRVxuICAgIHx8IChwcm9jZXNzLmVudi5IT01FUEFUSCA/ICgocHJvY2Vzcy5lbnYuSE9NRURSSVZFIHx8ICdDOi8nKSArIHByb2Nlc3MuZW52LkhPTUVQQVRIKSA6IG51bGwpIHx8IG9zLmhvbWVkaXIoKTtcblxuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLnJlc29sdmUoaG9tZURpciwgJy5hd3MnLCAnY29uZmlnJykpKSB7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NES19MT0FEX0NPTkZJRyA9ICcxJztcbiAgfVxufVxuXG4vKipcbiAqIFJlYWQgYSBmaWxlIGlmIGl0IGV4aXN0cywgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICpcbiAqIE5vdCBhc3luYyBiZWNhdXNlIGl0IGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHJlYWRJZlBvc3NpYmxlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGlmICghZnMucGF0aEV4aXN0c1N5bmMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoZSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzUmVnZXgocmU6IFJlZ0V4cCwgczogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIHJldHVybiBzICE9PSB1bmRlZmluZWQgJiYgcmUuZXhlYyhzKSAhPT0gbnVsbDtcbn1cbiJdfQ==