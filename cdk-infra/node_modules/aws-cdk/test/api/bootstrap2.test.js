"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mockDeployStack = jest.fn();
jest.mock('../../lib/api/deploy-stack', () => ({
    deployStack: mockDeployStack,
}));
const bootstrap_environment2_1 = require("../../lib/api/bootstrap/bootstrap-environment2");
const mock_sdk_1 = require("../util/mock-sdk");
describe('Bootstrapping v2', () => {
    const env = {
        account: '123456789012',
        region: 'us-east-1',
        name: 'mock',
    };
    const sdk = new mock_sdk_1.MockSDK();
    test('passes the bucket name as a CFN parameter', async () => {
        await bootstrap_environment2_1.bootstrapEnvironment2(env, sdk, 'mockStack', undefined, {
            bucketName: 'my-bucket-name',
        });
        expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({
            parameters: {
                FileAssetsBucketName: 'my-bucket-name',
            },
        }));
    });
    test('passes the KMS key ID as a CFN parameter', async () => {
        await bootstrap_environment2_1.bootstrapEnvironment2(env, sdk, 'mockStack', undefined, {
            kmsKeyId: 'my-kms-key-id',
        });
        expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({
            parameters: {
                FileAssetsBucketKmsKeyId: 'my-kms-key-id',
            },
        }));
    });
    test('passing trusted accounts without CFN managed policies results in an error', async () => {
        await expect(bootstrap_environment2_1.bootstrapEnvironment2(env, sdk, 'mockStack', undefined, {
            trustedAccounts: ['123456789012'],
        }))
            .rejects
            .toThrow('--cloudformation-execution-policies are required if --trust has been passed!');
    });
    afterEach(() => {
        mockDeployStack.mockClear();
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwMi50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwMi50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBRWxDLElBQUksQ0FBQyxJQUFJLENBQUMsNEJBQTRCLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUM3QyxXQUFXLEVBQUUsZUFBZTtDQUM3QixDQUFDLENBQUMsQ0FBQztBQUVKLDJGQUF1RjtBQUN2RiwrQ0FBMkM7QUFFM0MsUUFBUSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRTtJQUNoQyxNQUFNLEdBQUcsR0FBRztRQUNWLE9BQU8sRUFBRSxjQUFjO1FBQ3ZCLE1BQU0sRUFBRSxXQUFXO1FBQ25CLElBQUksRUFBRSxNQUFNO0tBQ2IsQ0FBQztJQUNGLE1BQU0sR0FBRyxHQUFHLElBQUksa0JBQU8sRUFBRSxDQUFDO0lBRTFCLElBQUksQ0FBQywyQ0FBMkMsRUFBRSxLQUFLLElBQUksRUFBRTtRQUMzRCxNQUFNLDhDQUFxQixDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRTtZQUM1RCxVQUFVLEVBQUUsZ0JBQWdCO1NBQzdCLENBQUMsQ0FBQztRQUVILE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7WUFDbkUsVUFBVSxFQUFFO2dCQUNWLG9CQUFvQixFQUFFLGdCQUFnQjthQUN2QztTQUNGLENBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsMENBQTBDLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDMUQsTUFBTSw4Q0FBcUIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUU7WUFDNUQsUUFBUSxFQUFFLGVBQWU7U0FDMUIsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUNuRSxVQUFVLEVBQUU7Z0JBQ1Ysd0JBQXdCLEVBQUUsZUFBZTthQUMxQztTQUNGLENBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsMkVBQTJFLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDM0YsTUFBTSxNQUFNLENBQUMsOENBQXFCLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFO1lBQ25FLGVBQWUsRUFBRSxDQUFDLGNBQWMsQ0FBQztTQUNsQyxDQUFDLENBQUM7YUFDRixPQUFPO2FBQ1AsT0FBTyxDQUFDLDhFQUE4RSxDQUFDLENBQUM7SUFDM0YsQ0FBQyxDQUFDLENBQUM7SUFFSCxTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ2IsZUFBZSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQzlCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtb2NrRGVwbG95U3RhY2sgPSBqZXN0LmZuKCk7XG5cbmplc3QubW9jaygnLi4vLi4vbGliL2FwaS9kZXBsb3ktc3RhY2snLCAoKSA9PiAoe1xuICBkZXBsb3lTdGFjazogbW9ja0RlcGxveVN0YWNrLFxufSkpO1xuXG5pbXBvcnQgeyBib290c3RyYXBFbnZpcm9ubWVudDIgfSBmcm9tICcuLi8uLi9saWIvYXBpL2Jvb3RzdHJhcC9ib290c3RyYXAtZW52aXJvbm1lbnQyJztcbmltcG9ydCB7IE1vY2tTREsgfSBmcm9tICcuLi91dGlsL21vY2stc2RrJztcblxuZGVzY3JpYmUoJ0Jvb3RzdHJhcHBpbmcgdjInLCAoKSA9PiB7XG4gIGNvbnN0IGVudiA9IHtcbiAgICBhY2NvdW50OiAnMTIzNDU2Nzg5MDEyJyxcbiAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgIG5hbWU6ICdtb2NrJyxcbiAgfTtcbiAgY29uc3Qgc2RrID0gbmV3IE1vY2tTREsoKTtcblxuICB0ZXN0KCdwYXNzZXMgdGhlIGJ1Y2tldCBuYW1lIGFzIGEgQ0ZOIHBhcmFtZXRlcicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBib290c3RyYXBFbnZpcm9ubWVudDIoZW52LCBzZGssICdtb2NrU3RhY2snLCB1bmRlZmluZWQsIHtcbiAgICAgIGJ1Y2tldE5hbWU6ICdteS1idWNrZXQtbmFtZScsXG4gICAgfSk7XG5cbiAgICBleHBlY3QobW9ja0RlcGxveVN0YWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXROYW1lOiAnbXktYnVja2V0LW5hbWUnLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH0pO1xuXG4gIHRlc3QoJ3Bhc3NlcyB0aGUgS01TIGtleSBJRCBhcyBhIENGTiBwYXJhbWV0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYm9vdHN0cmFwRW52aXJvbm1lbnQyKGVudiwgc2RrLCAnbW9ja1N0YWNrJywgdW5kZWZpbmVkLCB7XG4gICAgICBrbXNLZXlJZDogJ215LWttcy1rZXktaWQnLFxuICAgIH0pO1xuXG4gICAgZXhwZWN0KG1vY2tEZXBsb3lTdGFjaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICBGaWxlQXNzZXRzQnVja2V0S21zS2V5SWQ6ICdteS1rbXMta2V5LWlkJyxcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9KTtcblxuICB0ZXN0KCdwYXNzaW5nIHRydXN0ZWQgYWNjb3VudHMgd2l0aG91dCBDRk4gbWFuYWdlZCBwb2xpY2llcyByZXN1bHRzIGluIGFuIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGV4cGVjdChib290c3RyYXBFbnZpcm9ubWVudDIoZW52LCBzZGssICdtb2NrU3RhY2snLCB1bmRlZmluZWQsIHtcbiAgICAgIHRydXN0ZWRBY2NvdW50czogWycxMjM0NTY3ODkwMTInXSxcbiAgICB9KSlcbiAgICAucmVqZWN0c1xuICAgIC50b1Rocm93KCctLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llcyBhcmUgcmVxdWlyZWQgaWYgLS10cnVzdCBoYXMgYmVlbiBwYXNzZWQhJyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgbW9ja0RlcGxveVN0YWNrLm1vY2tDbGVhcigpO1xuICB9KTtcbn0pO1xuIl19